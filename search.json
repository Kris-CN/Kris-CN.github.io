[{"title":"LC1.两数之和","url":"/posts/1669048921/","content":"\n## 题目地址(1. 两数之和)\n\nhttps://leetcode-cn.com/problems/two-sum/\n\n## 题目描述\n\n```\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n \n\n示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n \n\n提示：\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\n只会存在一个有效答案\n\n进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n```\n\n## 前置知识\n\n- 哈希表的元素存在判断，哈希表的存储和读出\n\n## 公司\n\n- Amazon、字节跳动、谷歌、微软、苹果\n\n## 思路  \n此题作为LeetCode的第一题，最容易想到的就是使用暴力的方法进行枚举，O(N^2)的复杂度就可以将最终结果解出来，但是这样的效率是非常低的，显然不是题目本身的意图。这里可以使用哈希表的解法，每次将nums中元素添加到哈希表中时，使用containsKey()进行判断，判断是否有相加为target的元素已经存在哈希表中，如果存在直接返回对应的下标，如果没有，则将当前元素以num[i]为key，索引为value存入到哈希表中。\n## 关键点\n\n-  哈希表的使用，containsKey()的使用。可以直接返回新建的数组，这样代码更加简洁高效。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] index=new int[2];\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(target-nums[i])){\n                return new int[]{map.get(target-nums[i]),i};\n            }\n            map.put(nums[i],i);\n        }\n\n        return index;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","tags":["LeetCode","哈希表"],"categories":["LeetCode","哈希表"]},{"title":"LC283.移动零","url":"/posts/254845430/","content":"\n#### 题目地址(283. 移动零)\n\nhttps://leetcode-cn.com/problems/move-zeroes/\n\n#### 题目描述\n\n```\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n示例:\n\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n说明:\n\n必须在原数组上操作，不能拷贝额外的数组。\n尽量减少操作次数。\n```\n\n#### 前置知识\n\n- 双指针\n\n#### 公司\n\n- Facebook 、字节跳动、微软、苹果等\n\n#### 思路\n这个题本身并不难，使用暴力循环比较一定能做出来，而且代码逻辑也不复杂，但是效率非常的低，这里采用另一种思路：使用双指针，即设置一个pre和last两个指针，pre指向首部，last指向尾部。在正式比较前可以使用两个指针缩短一下比较范围，当首部有非零数时，pre指针向右移动，当尾部有零时，last向左移动。正式比较时，最外层循环代表要比较的数，注意这里不要直接i++，这样出现一个问题：当两个连续的零在一起的时候，第一个零正常移动到最后时，i此时停留在1处，然而第二个零已经到了i=0的位置上了，这样就会出现遗漏的情况。进入第二层循环的时候，就是进行换位的操作，这里也有一个比较坑的点，就是j要从i开始，不能从0开始，否则会出现把第0号元素给调换，但实际上根据逻辑，i之前的已经全部是非零数了（只有非零，i才会++），切记j从i开始，然后每一次将零换到最后，last都向前移动一个，下次就不用比较了，直到最后。\n#### 关键点\n\n-  注意两次循环的循环条件\n\n#### 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int pre,last;\n        pre=0;\n        last=nums.length-1;\n        // if(nums[last]==0) last--;\n        while(nums[last]==0&&last>0){\n            last--;\n        }\n        while(nums[pre]!=0&&pre<last){\n            pre++;\n        }\n        for(int i=0;i<=last;){\n            if(nums[i]==0){\n                for(int j=i;j<last;j++){\n                    nums[j]+=nums[j+1];\n                    nums[j+1]=nums[j]-nums[j+1];\n                    nums[j]=nums[j]-nums[j+1];\n                }\n                last--;\n            }\n            else {i++;}\n        }\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","tags":["LeetCode","排序"],"categories":["LeetCode"]},{"title":"剑指 Offer 45. 把数组排成最小的数","url":"/posts/1504228604/","content":"####  题目  \n[传送门](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)\n\n#### 解题思路\n这题属实让eclipse坑了一把，不说那话。这题我一开始想的复杂了，最开始想用的HashMap进行求解，将最高位按照低到高进行排列，每个最高位内部再进行一次排列，这样最后就直接按顺序将所有的整数以字符串的形式拼接并输出就可以，但是还是太年轻了，如果只考虑最高位的话，会出现多个最高位相同的情况例如：334,35,369等等，这样的话就会导致一个问题，即多个相同值的key（最高位都一样）都会指向唯一一个value，这样最后每一种最高位都只剩下一个数，显然不合要求；第二次考虑使用二维数组进行实现，同样遇到了不可弥补的问题。最后，还是采用了题解中的一种做法，就是相邻两个数进行正反拼接，若nums[j]+nums[j+1]>nums[j+1]+nums[j],注意这里的加法是字符串的加法，不是数字相加，nums[j]应移动到j+1的后面去，这里的排序就是用冒泡（毕竟要求用冒泡），排序完成后再按照顺序进行字符串拼接，最后进行输出。其实这里涉及到一个问题，也就是排序规则的传递性问题，意思是，每次比较都是相邻两个数拼接之后比较，排序完成后怎样保证字符串 满足xy < yx , yz < zy 时 xz < zx 一定成立。后面给出K神关于传递性的证明。  \n####  传递性证明  \n```\n设十进制数 x, y, z 分别有 a, b, c 位，则有：\n（左边是字符串拼接，右边是十进制数计算，两者等价）\nxy = x * 10^b + y \nyx = y * 10^a + x\n\n则 xy < yx 可转化为：\nx * 10^b + y < y * 10^a + x\nx (10^b - 1) < y (10^a - 1)\nx / (10^a - 1) < y / (10^b - 1)     ①\n\n同理， 可将 yz < zy 转化为：\ny / (10^b - 1) < z / (10^c - 1)     ②\n\n将 ① ② 合并，整理得：\nx / (10^a - 1) < y / (10^b - 1) < z / (10^c - 1)\nx / (10^a - 1) < z / (10^c - 1)\nx (10^c - 1) < z (10^a - 1)\nx * 10^c + z < z * 10^a + x\n∴  可推出 xz < zx ，传递性证毕\n```\n\n#### 代码\n\n```java\nclass Solution {\n    public String minNumber(int[] nums) {\n               String[] str=new String[nums.length];\n       for(int i=0;i<nums.length;i++) {\n    \t   str[i]=nums[i]+\"\";\n       }\n       boolean swapped=true;\n       for(int i=0;i<str.length-1;i++) {\n    \t   if(!swapped) {\n    \t\t   break;\n    \t   }\n    \t   swapped=false;\n    \t   for(int j=0;j<str.length-1-i;j++) {\n    \t\t   if((str[j]+str[j+1]).compareTo(str[j+1]+str[j])>=0) {\n                     String tmp=\"\";\n\t\t             tmp=str[j];\n\t\t             str[j]=str[j+1];\n\t\t             str[j+1]=tmp;\n    \t\t\t   swapped=true;\n    \t\t   }\n    \t   }\n       }\n\n       String res=\"\";\n       for(String v:str) {\n    \t   res+=v;\n       }\n       return res;\n    }\n}\n```\n####  知识点  \n#####  比较两个String字符串类型数据大小  \n###### 方法一   \n如果两个数String字符串中只包含数字0~9和小数点  \n```\nString a = \"32\";\nString b = \"334\";\n\n// 首先将两个数都转换为int 数据\nint a_N = Integer.valueOf(a);\nint b_N = Integer.valueOf(b);\n// 比较大小\nboolean res = a_N > b_N;\n\n```\n###### 方法二  \n如果两个String字符串中包含字母，则使用a.compareTo(b)函数  \n该方法是用于判断一个字符串时大于、等于还是小于另一个字符串。判断字符串大小的一句是根据他们在字典中的顺序决定的。  \n```\n   语法：str1.compareTo(str2);\n\n```\n该函数的返回值为int类型  \n若str1等于参数字符串str2，则返回0；  \n若str1大于参数字符串str2，则返回值大于0；   \n若str1小于参数字符串str2，则返回值小于0；  \nJava中的compareTo()方法，返回参与比较的前后两个字符串的ASCII码的差值  \n```\nString a = \"3\";\nString b = \"32a\";\nint res = a.compareTo(b); // 如果 a > b 则返回res > 0; \n\t\t\t\t\t\t// 如果 a < b 则返回res < 0; \n```\n#####  数组的长度   \n```\nnums.length;\n```\n","tags":["LeetCode","排序"],"categories":["LeetCode","排序"]},{"title":"LeetCode冒泡排序","url":"/posts/1343146864/","content":"#####   就是传统的冒泡冒泡排序，注释中写的还是比较清楚的的，可以直接读，代码如下：  \n```java\npublic class Solution {\n\tpublic static void swag(int[] arr,int i,int j) {//交换两个数，使用第三方变量的情况\n\t\tint tmp;\n\t\ttmp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=tmp;\n\t}\n\tpublic static void swag_nonum(int[] arr,int i,int j) {\n    //交换两个数，不使用第三方变量进行转换，利用加减来进行数值的交换\n\t\t\n\t\tarr[i]+=arr[j];\n\t\tarr[j]=arr[i]-arr[j];\n\t\tarr[i]=arr[i]-arr[j];\n\t}\n    \tpublic static void swag_binary(int[] arr,int i,int j) {\n        //交换两个数，不使用第三方变量进行转换，利用异或操作的交换\n\t\t\n\t\tarr[i]^=arr[j];\n\t\tarr[j]^=arr[i];\n\t\tarr[i]^=arr[j];\n\t\t\n\t}\n\tpublic static void BubbleSort(int[] arr) {\n\t\tboolean swapped=true;// 初始时 swapped 为 true，否则排序过程无法启动\n\t\tfor(int i=0;i<arr.length-1;i++) {//-1是为了防止越界\n\t\t\tif(!swapped) break;\n\t\t\t // 设置 swapped 为 false，如果发生交换，则将其置为 true\n\t\t\tswapped=false;\n\t\t\tfor(int j=0;j<arr.length-1-i;j++) {//减去i是因为每次都会排好一个，不用每次都遍历到最后一个，最后的一个已经是最大的了\n\t\t\t\tif(arr[j]>arr[j+1]) {//比较相邻的两个数的大小，小心数组越界的情况\n\t\t\t\t\t // 如果左边的数大于右边的数，则交换，保证右边的数字最大\n\t\t\t\t\tswag(arr,j,j+1);\n\t\t\t\t\tswapped=true; // 表示发生了交换\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tint arr[]= {9,8,6,4,1,5,9,36,54,7,0,2,5,-1,78};\n\t\tBubbleSort(arr);\n\t\tfor (int i : arr) {\n\t\t\tSystem.out.print(i+\",\");\n\t\t}\n\t\t\n\t}\n\n\n}\n```\n这里在两个数据交换上用了三种方法，一种是用传统的方法，引入第三方变量作为临时存储的介质；另一种采用加法的性质，现将两数（a,b）之和赋值给a，然后用a减去b字得到a的原值并赋值给b，此时再用a-b获得b原来的值并赋值给a，完成两个数之间的交换；最后一种是评论区大神给的异或计算(注意是异或不是加法)进行交换的方法，为了防止第二种情况大数加减时出现的溢出问题。  \n#####  每日一图  \n![](https://img-blog.csdnimg.cn/20210918181931967.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aeL57uI5Zyo5Luw5pyb5aSn5L2s,size_20,color_FFFFFF,t_70,g_se,x_16)","tags":["LeetCode","排序"],"categories":["LeetCode","排序"]},{"title":"剑指offer58.2左旋转字符串（字符串思路）","url":"/posts/3310038826/","content":"#### 题目描述  \n\n#### 思路  \n这一篇与上一篇的区别是，上一篇使用栈来实现，效率非常的低，击败5%也就，这一篇用的是Java对字符串的种种操作来实现的，思路很简单，就是对字符串进行切片或者取余等等。\n#### 代码1  \n因为String类型属于不可变对象，所以使用StringBuilder进行单个字符的添加，将读取到的单个字符添加到StringBuilder中去，最后直接输出就好。\n```java\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        StringBuilder res=new StringBuilder();\n        for(int i=n;i<s.length();i++){\n            res.append(s.charAt(i));\n        }\n        for(int i=0;i<n;i++){\n            res.append(s.charAt(i));//这里遍历到并被添加的元素在StringBuilder中已经不存在了。\n        }\n        return res.toString();//根据返回类型将res强制转换成String类型\n    }\n}\n\n```\n#### 代码2  \n这一部分比上面的要求更加苛刻，不允许使用StringBuilder方法，只能使用Strin数据类型，此时使用字符串遍历拼接，时间和空间复杂度都是O(N)，代码如下：  \n```java\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        // StringBuilder res=new StringBuilder();\n        String res=\"\";\n        for(int i=n;i<s.length();i++){\n            res+=s.charAt(i);\n        }\n        for(int i=0;i<n;i++){\n            res+=s.charAt(i);\n        }\n        return res;\n    }\n}\n```\n可以通过取余操作简化代码，还是比较好用和巧妙的。  \n```java\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        // StringBuilder res=new StringBuilder();\n        String res=\"\";\n        for(int i=n;i<n+s.length();i++){\n            res+=s.charAt(i%s.length());\n        }\n\n        return res;\n    }\n}\n```\n####  三种方法分析  \n#####  切片法  \n新建两个切片字符串，并将两切片拼接为结果字符串，无冗余操作，效率最高。\n#####  列表遍历拼接  \n列表(Python) 和 StringBuilder(Java) 都是可变对象，每轮遍历拼接字符时，只是向列表尾部添加一个新的字符元素。最终拼接转化为字符串时，系统***仅申请一次内存***。\n#####  字符串遍历拼接  \n在 Python 和 Java 中，字符串是 “不可变对象” 。因此，每轮遍历拼接字符时，都需要新建一个字符串；因此，***系统 需申请 N次内存***，数据量较大时效率低下。\n","tags":["LeetCode","字符串"],"categories":["LeetCode","字符串"]},{"title":"剑指offer58.2左旋转字符串","url":"/posts/1192196225/","content":"#### 题目 \n[传送门](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n#### 解题思路\n第一中做法用LinkedList模拟的双栈，效率有点低啊  \n第二种利用LinkedList的双向性直接头尾添加，一个栈输出。\n\n#### 代码（双栈）\n\n```java\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        // Char[] a=new Char[s.length];\n    //    a= s.toCharAt();\n    // StringBuilder str=new StringBuilder(s);\n    LinkedList<Character> stack1=new LinkedList<>();\n    LinkedList<Character> stack2=new LinkedList<>();\n    for (int i =0;i<s.length();i++){\n        if(n>0){\n            stack2.addLast(s.charAt(i));\n            n--;\n        }\n        else \n            stack1.addLast(s.charAt(i));\n    }\n    String str=\"\"; \n    while(!stack1.isEmpty()){\n        str+=stack1.removeFirst();\n    }\n    while(!stack2.isEmpty()){\n        str+=stack2.removeFirst();\n    }\n   \n    return str;\n    }\n}\n```\n#### 代码（单栈）\n```java\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n    if(s.length()==1) return s;\n    LinkedList<Character> stack1=new LinkedList<>();\n    for (int i =n;i<s.length();i++){\n            stack1.addFirst(s.charAt(i));\n    }\n    String str=\"\"; \n    for(int i=0;i<n;i++){\n        stack1.addFirst(s.charAt(i));\n    }\n    while(!stack1.isEmpty()){\n        str+=stack1.removeLast();\n    }\n   \n    return str;\n    }\n}\n```","tags":["LeetCode","链表"],"categories":["LeetCode","链表"]},{"title":"剑指offer35.复杂链表复制","url":"/posts/2747444045/","content":"#### 题目要求  \n[传送门](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)\n#### 解题思路\n不得不说，大佬的代码对我这种小白来说就是一种恩赐啊。用的是哈希表进行操作的。   \n利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。\n\n算法流程：  \n若头节点` head `为空节点，直接返回 `null`；  \n初始化： 哈希表 dic ， 节点 cur 指向头节点；\n复制链表：  \n建立新节点，并向 dic 添加键值对 (原 cur 节点, 新 cur 节点） ；\ncur 遍历至原链表下一节点；   \n构建新链表的引用指向：   \n构建新节点的 next 和 random 引用指向；\ncur 遍历至原链表下一节点；    \n返回值： 新链表的头节点 dic[cur] ；   \n复杂度分析：    \n时间复杂度 O(N)O(N) ： 两轮遍历链表，使用 O(N)O(N) 时间。\n空间复杂度 O(N)O(N) ： 哈希表 dic 使用线性大小的额外空间。   \n&emsp;&emsp;其实就是先复制一个普通的链表出来，然后通过map的方式找到next与random的位置，然后依次赋值给新节点的相应指针指向，最有意思的就是next和random复制的地方，要好好琢磨，有味道。\n\n#### 代码\n\n```java\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if(head == null) return null;//头结点为空直接返回，防止出现空指针异常\n        Node cur=new Node(head.val);\n        cur=head;\n         Map<Node,Node> map=new HashMap<>();\n        //    Map<Node, Node> map = new HashMap<>();\n        while(cur!=null){\n            map.put(cur, new Node(cur.val));\n            cur=cur.next;\n        }//这里完成的是普通的复制。\n        cur=head;//这里将cur推回到的开头，准备完成next和random的连接。\n        while(cur!=null){\n            map.get(cur).next=map.get(cur.next);\n            map.get(cur).random=map.get(cur.random);\n            cur=cur.next;\n        }\n        return map.get(head);//因为是旧节点映射新节点，所以直接使用map通过head（一直没动）找到新节点的起始位置，然后直接返回就可以。\n\n    }\n}\n\n```","tags":["LeetCode","链表"],"categories":["LeetCode","链表"]},{"title":"剑指 Offer 20. 表示数值的字符串","url":"/posts/626924734/","content":"#### 题目描述  \n传送门  \n#### 题解  \n我首先想到的是判断否false而不是判断是true，毕竟有这么多条件满足才能判断true，但是只要有一个条件不满足就可以判断false，最后代码的效率也还可以：  \n\n首先定义了四个flag，对应四种字符  \n是否有数字：hasNum  \n是否有e：hasE  \n是否有正负符号：hasSign  \n是否有点：hasDot   \n其余还定义了字符串长度n以及字符串索引index  \n先处理一下开头的空格，index相应的后移  \n然后进入循环，遍历字符串  \n如果当前字符c是数字：将hasNum置为true，index往后移动一直到非数字或遍历到末尾位置；如果已遍历到末尾(index == n)，结束循环   \n如果当前字符c是'e'或'E'：如果e已经出现或者当前e之前没有出现过数字，返回fasle；否则令hasE = true，并且将其他3个flag全部置为false，因为要开始遍历e后面的新数字了   \n如果当前字符c是+或-：如果已经出现过+或-或者已经出现过数字或者已经出现过'.'，返回flase；否则令hasSign = true   \n如果当前字符c是'.'：如果已经出现过'.'或者已经出现过'e'或'E'，返回false；否则令hasDot = true   \n如果当前字符c是' '：结束循环，因为可能是末尾的空格了，但也有可能是字符串中间的空格，在循环外继续处理   \n如果当前字符c是除了上面5种情况以外的其他字符，直接返回false处理空格，index相应的后移。     \n如果当前索引index与字符串长度相等，说明遍历到了末尾，但是还要满足hasNum为true才可以最终返回true，因为如果字符串里全是符号没有数字的话是不行的，而且e后面没有数字也是不行的，但是没有符号是可以的，所以4个flag里只要判断一下hasNum就行；所以最后返回的是hasNum && index == n    \n如果字符串中间有空格，按以上思路是无法遍历到末尾的，index不会与n相等，返回的就是false   \n\n\n####  代码  \n\n```java\nclass Solution {\n    public boolean isNumber(String s) {\n        int n = s.length();\n        int index = 0;\n        boolean hasNum = false, hasE = false;\n        boolean hasSign = false, hasDot = false;\n        while(index < n && s.charAt(index) == ' ')\n            index++;\n        while(index < n){\n            while(index < n && s.charAt(index) >= '0' && s.charAt(index) <= '9'){\n                index++;\n                hasNum = true;\n            }\n            if(index == n){\n                break;\n            }\n            char c = s.charAt(index);\n            if(c == 'e' || c == 'E'){\n                if(hasE || !hasNum){\n                    return false;\n                }\n                hasE = true;\n                hasNum = false; hasSign = false; hasDot = false;\n            }else if(c == '+' || c == '-'){\n                if(hasSign || hasNum || hasDot){\n                    return false;\n                }\n                hasSign = true;\n            }else if(c == '.'){\n                if(hasDot || hasE){\n                    return false;\n                }\n                hasDot = true;\n            }else if(c == ' '){\n                break;\n            }else{\n                return false;\n            }\n            index++;\n        }\n        while(index < n && s.charAt(index) == ' ')\n            index++;\n        return hasNum && index == n;\n    }\n}\n\n```","tags":["LeetCode","链表"],"categories":["LeetCode","链表"]},{"title":"剑指offer09. 用两个栈实现队列","url":"/posts/3798182208/","content":"#### 题目描述  \n传送门  \nhttps://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/  \n\n#### 解题思路\n这里还是不建议使用stack，使用LinkedList代替，由于Stack继承了Vector接口，而Vector底层是一个Object[]数组，那么就要考虑空间扩容和移位的问题了。 可以使用LinkedList来做Stack的容器，因为LinkedList实现了Deque接口，所以Stack能做的事LinkedList都能做，其本身结构是个双向链表，扩容消耗少。 但是我的意思不是像100%代码那样直接使用一个LinkedList当做队列，那确实是快，但是不符题意。加上LinkedList本身作为双链表，可以使用addFirst()、addLast()等操作在不同位置上进行添加和删除操作。这里使用两个栈，一个用来接受的，在后面去除元素的时候，将第一个栈的元素压入第二个中，然后再从顶端进行返回。\n#### 代码\n\n```java\nclass CQueue {\n    LinkedList<Integer> stack1;\n     LinkedList<Integer> stack2;\n    public CQueue() {\n        stack1=new LinkedList<Integer>();\n        stack2=new LinkedList<Integer>();\n    }\n    \n    public void appendTail(int value) {\n        stack1.addLast(value);\n    }\n    \n    public int deleteHead() {\n        if(stack2.isEmpty()){\n            if(stack1.isEmpty()){\n                return -1;\n            }\n            while(!stack1.isEmpty()){\n                stack2.addLast(stack1.removeLast());\n            }\n            return stack2.removeLast();//注意这里要添加返回值，if-else中很容易出现这种漏掉返回值的问题\n        }\n        else \n             return stack2.removeLast();\n    }\n\n}\n\n/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue obj = new CQueue();\n * obj.appendTail(value);\n * int param_2 = obj.deleteHead();\n */\n```","tags":["LeetCode"],"categories":["LeetCode"]},{"title":"剑指offer06，从头到尾打印链表","url":"/posts/2308668757/","content":"#### 题目描述  \n传送门  \nhttps://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\n#### 解题思路  \n数据结构，使用LinkedList模拟栈操作，使用addFirst(),removeLast()。比较简单，尽量不要使用stack，LinkedList具有线程安全性，推荐使用。\n\n#### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int[] reversePrint(ListNode head) {\n        LinkedList<Integer> stack=new LinkedList<Integer>();\n        int accout=0;\n        while(head!=null){\n            stack.addLast(head.val);\n            head=head.next;\n            accout++;\n        }\n        //stack.removeLast();\n        int[] res=new int[accout];\n        int i=0;\n        while(accout>0) {\n            res[i]=stack.removeLast();\n            i++;\n            accout--;\n        }\n        return res;\n    }\n}\n\n\n```"},{"title":"LCP18.早餐组合","url":"/posts/3310632163/","content":"#### 题目  \n！[传送门](https://leetcode-cn.com/problems/2vYnGI/)题目太长就不描述了\n#### 解题思路\n双指针（最好理解），对向双指针，取一个数组做完全遍历，关键步骤的思路在注释中。\n\n#### 代码\n\n```java\nclass Solution {\n    public int breakfastNumber(int[] staple, int[] drinks, int x) {\n        int ps = 0, pd = drinks.length - 1, count = 0;\n        Arrays.sort(staple);\n        Arrays.sort(drinks);\n        while (ps < staple.length && pd >= 0) {\n             if (staple[ps] + drinks[pd] <= x) {\n                count += pd + 1;//这里满足条件之后，此处之前的左右元素都满足条件，因为是有序的。\n                count = count % 1000000007;\n                ps++;//staple左侧指针向前推进一个，直至全部遍历完staple数组。\n            } else {//如果超出规定则drink数组右侧指针向前推进一个。\n                pd--;\n            }\n        }\n        return count;\n    }\n}\n\n```","tags":["LeetCode","二分"],"categories":["LeetCode","二分"]},{"title":"852.山脉数组的峰顶索引","url":"/posts/1792943448/","content":"#### 描述  \n符合下列属性的数组 arr 称为 山脉数组 ：  \narr.length >= 3  \n存在 i（0 < i < arr.length - 1）使得：  \narr[0] < arr[1] < ... arr[i-1] < arr[i]  \narr[i] > arr[i+1] > ... > arr[arr.length - 1]  \n给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i 。  \n\n**示例 1：**  \n输入：arr = [0,1,0]  \n输出：1  \n**示例 2：**    \n输入：arr = [0,2,1,0]    \n输出：1  \n**示例 3：  **  \n输入：arr = [0,10,5,2]    \n输出：1    \n**示例 4：**    \n输入：arr = [3,4,5,1]    \n输出：2    \n**示例 5： **     \n输入：arr = [24,69,100,99,79,78,67,36,26,19]    \n输出：2    \n \n#### 解题思路  \n常规的二分，思路还是比较简单的，正常设置left、mid、right，在中间的时候判断mid两边的元素：1.当nums[mid]<nums[mid-1]时，证明还没到峰值，right移动到mid左侧；2.当nums[mid]>nums[mid-1]时再判断是否nums[mid]>nums[mid+1]，若成立证明找到峰值，直接返回mid，若不成立则证明已经过了峰值，此时将reft移动到mid右边。这里要注意越界的问题，在计算完mid后判断一下是否已经到达最低点（0），若达到直接推出循环，同时返回right（因为在你计算mid后，mid已经移动到right左边，此时mid为0已经不能比较了，所以之前保留的right一定就是峰值）。这是常规做法，后面有更高效率的写法我再研究研究。\n#### 代码\n\n```java\nclass Solution {\n    public int peakIndexInMountainArray(int[] arr) {\n\tint left,mid,right;\n    left=0;\n     mid=10;\n    right=arr.length-1;\n    while(right>=left){\n        mid=left+(right-left)/2;\n        if(mid==0) return right;\n        if(arr[mid]<arr[mid-1]){\n            right=mid-1;\n            }\n        else if(arr[mid]>arr[mid-1]){\n            if(arr[mid]>arr[mid+1])\n                return mid;\n            else left=mid+1;\n            }\n        }\n        return right;\n    }\n}\n```","tags":["LeetCode"],"categories":["LeetCode"]},{"title":"9-5随笔","url":"/posts/3121163870/","content":"&emsp;&emsp;人总是会成为成为自己讨厌的人，并乐于成为自己讨厌的人，何为讨厌？嫉妒罢了。\n![](https://img-blog.csdnimg.cn/20210905234037133.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aeL57uI5Zyo5Luw5pyb5aSn5L2s,size_20,color_FFFFFF,t_70,g_se,x_16)","tags":["感悟"],"categories":["感悟"]},{"title":"1351.统计有序矩阵中的负数(高复杂度)","url":"/posts/936958119/","content":"#### 描述  \n(传送门)[https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix]  \n给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。   \n请你统计并返回 grid 中 负数 的数目。\n\n示例 1：  \n`\n输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]   \n输出：8  \n解释：矩阵中共有 8 个负数。\n`  \n示例 2：  \n`\n输入：grid = [[3,2],[1,0]]  \n输出：0  \n`  \n示例 3：  \n`\n输入：grid = [[1,-1],[-1,-1]]  \n输出：3\n`  \n示例 4：  \n`\n输入：grid = [[-1]]  \n输出：1\n`  \n提示：\n\nm == grid.length  \nn == grid[i].length  \n1 <= m, n <= 100  \n-100 <= grid[i][j] <= 100  \n\n#### 解题思路\n没啥好说的二分查找，对每一个二维数组中的每一行进行一个二分，一个for循环就够了，用来遍历每一行。这里注意越界的问题，因为是数组，在while中要加入一个边界的判断，内部两个if即可，大于等于0在一起。主要是最后的sum，注意减去的是left的值，因为left在最后一轮的判断中会移动到最先出现的那个负数那里，然而right判断是负数后会继续向左移动（因为此时不知道当前负数是不是最早的负数，同样left判断的是非零数，其无法识别是不是最后一个非零数，当判断是非零数向后移动一个且left大于right时此时找到了第一个负数），因此使用grid&#x5B;i&#x5D;.length-left。全部循环完毕后得到最后的sum值。二分就是细节怪~~~~\n\n#### 代码\n\n```java\nclass Solution {\n    public int countNegatives(int[][] grid) {\n        \t\tint sum=0;\n        for (int i = 0; i < grid.length; i++) {\n\n        \tint left,mid,right;\n        \tleft=0;\n        \tright=grid[i].length-1;\n\t\t\tmid=0;\n\t\t\twhile(right>=left&&left<=grid[i].length&&right>=0) {\n\t\t\t\tmid=left+(right-left)/2;\n\t\t\t\tif(grid[i][mid]>=0) {\n\t\t\t\t\tleft=mid+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tright=mid-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum+=grid[i].length-left;\n\t\t}\n        return sum;\n    }\n}\n```","tags":["LeetCode"],"categories":["LeetCode"]},{"title":"441.排硬币","url":"/posts/1209064847/","content":"####  题目描述  \n[传送门](https://leetcode-cn.com/problems/arranging-coins/)\n你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。\n给定一个数字 n，找出可形成完整阶梯行的总行数。\nn 是一个非负整数，并且在32位有符号整型的范围内。\n\n示例 1:\n```\nn = 5\n\n硬币可排列成以下几行:\n¤  \n¤ ¤  \n¤ ¤  \n\n因为第三行不完整，所以返回2.\n```\n示例 2:  \n```\nn = 8\n\n硬币可排列成以下几行:\n¤\n¤ ¤\n¤ ¤ ¤\n¤ ¤\n\n因为第四行不完整，所以返回3.\n```\n#### 解题思路\n两个坑吧算是：1.注意题目给定的范围，因为涉及到前n项求和，所以在极限测试的时候会超出限制，所以采用long的形式进行定义，后期再进行强转返回。2.当`right>=left`的条件不满足的时候，退出while循环后返回的是right，而不是mid，因为由大向小缩进，所以right代表的是最后的结果。这两点注意之后就没啥了，常规的二分法。  \n\n#### 代码\n\n```java\nclass Solution {\n\n    public int arrangeCoins(int n) {\n        long left,mid,right,sum;\n        left=1;\n        right=n;\n        mid=0;\n        while(right>=left){\n            mid=left+(right-left)/2;\n             sum=(1+mid)*mid/2;\n            if(sum>n){\n                right=mid-1;\n            }\n            else if(sum==n){\n                return (int)mid;\n            }\n            else {\n                left=mid+1;\n            }\n        }\n        return (int)right;\n        \n    }\n}\n```","tags":["LeetCode"],"categories":["LeetCode"]},{"title":"374.猜数字大小","url":"/posts/3692866884/","content":"#### 题目描述  \n猜数字游戏的规则如下：  \n\n每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。  \n如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。  \n你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：  \n\n+ -1：我选出的数字比你猜的数字小 pick < num   \n+ 1：我选出的数字比你猜的数字大 pick > num   \n+ 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num   \n返回我选出的数字。   \n**示例 1：**   \n`输入：n = 10, pick = 6  \n 输出：6  \n`  \n示例 2 ：  \n`  \n输入：n = 1, pick = 1  \n输出：1 \n`   \n示例 3：  \n`  \n输入：n = 2, pick = 1     \n输出：1  \n`    \n示例 4：  \n`\n输入：n = 2, pick = 2  \n输出：2  \n`  \n\n#### 解题思路\n&emsp;&emsp;传统想法，初始left为0，mid值为pick的值，right为2倍的pick值；pick小于规定值left移到mid，重新计算mid值，反之一样的操作，最后返回mid值，while循环不用啥判断条件，直接`while(true)`就好，体内有返回语句，注意，这种情况下，while外就不需要再return了，否则会报`UNreachable`错误，因为压根就执行不到那一步。\n\n#### 代码\n\n```java\n/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return \t     -1 if num is lower than the guess number\n *\t\t\t      1 if num is higher than the guess number\n *               otherwise return 0\n * int guess(int num);\n */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int left,mid,right;\n        left=0;\n        mid=n;\n        right=2*n;\n        while(true){\n        if(guess(mid)==1){\n            left=mid;\n            mid=left+(right-left)/2;\n        }\n        else if(guess(mid)==-1){\n            right=mid;\n            mid=left+(right-left)/2;\n        }\n        else return mid;\n        }\n        //return mid;\n    }   \n}\n```","tags":["LeetCode"]},{"title":"69.x的平方根","url":"/posts/499504488/","content":"####  问题描述  \n\n####  分析加代码1  \n&emsp;&emsp;第一种想法就是传统的二分算法，解题的依据是一个数的平方根一般不超过其`1/2`即`√x<=x/2`，但要注意特殊的情况1和0，这种情况单独讨论即可。这里注意`mid`的求法，如果不加一的话在最后会卡住，其他的没有什么问题了，就是正常的二分，代码如下：  \n```\nclass Solution {\n    public int mySqrt(int x) {\n        if(x==0)\n        return 0;\n        if(x==1)\n        return 1;\n        int left,right,mid;\n        left=1;\n        right=x/2;\n        \n        while(right>left){\n            mid=left+(right-left+1)/2;\n            if(mid>x/mid)\n                right=mid-1;\n            else \n                left=mid;\n        }\n        return left;\n    }\n}\n```\n上面的`if`判断中使用的是除法而不是乘法，是为了防止大整数溢出，除法可以有效避免这种情况。\n\n#### 分析加代码2  \n&emsp;&emsp;这是大佬提供的题解，使用牛顿迭代法，不得不说虽然没有学过数分，但是好歹学过一点高数，这一刻被捻的稀碎啊，后面的就是借鉴大佬的分析思路。  \n&emsp;&emsp;下面这种方法可以很有效地求出根号***a***的近似值：首先随便猜一个近似值***x***，然后不断令***x***等于***x***和***a/x***的平均数，迭代个六七次后***x***的值就已经相当精确了。例子如下： \n例如，我想求根号2等于多少。假如我猜测的结果为4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号2了：\n>( 4 + 2/ 4 ) / 2 = 2.25   \n>( 2.25 + 2/ 2.25 ) / 2 = 1.56944..  \n>( 1.56944..+ 2/1.56944..) / 2 = 1.42189..  \n>( 1.42189..+ 2/1.42189..) / 2 = 1.41423..     \n\n![牛顿迭代法](https://pic.leetcode-cn.com/c142efde7a7261c6c799d3269cee2f921dc5f5144a410b32afce4dbf036d0ed7-image.png)     \n代码如下：  \n```\nclass Solution {\n    int s;\n    \n public int mySqrt(int x) {\n     s=x;\n     if(x==0) return 0;\n    return ((int)(sqrts(x)));\n  }\n    \n    public double sqrts(double x){\n      double res = (x + s / x) / 2;\n    if (res == x) {\n      return x;\n    } else {\n      return sqrts(res);\n    }\n    } \n}\n```\n#### 补充牛顿迭代法（我记得张宇讲过这个也是不断逼近的）  \n+ 切线方程：以P为切点的切线方程：***y-f(a)=f'(a)(x-a)***  \n+ 牛顿迭代：\t\n![牛顿迭代法原理](https://img-blog.csdnimg.cn/20210905161450801.jpg)  \n","tags":["LeetCode"],"categories":["LeetCode"]},{"title":"35.搜索插入位置","url":"/posts/3915403668/","content":"#### 问题描述   \n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。   \n\n请必须使用时间复杂度为 O(log n) 的算法。  \n\n示例 1:  \n\n输入: nums = [1,3,5,6], target = 5\n输出: 2\n示例 2:\n\n输入: nums = [1,3,5,6], target = 2\n输出: 1\n示例 3:\n\n输入: nums = [1,3,5,6], target = 7\n输出: 4\n示例 4:\n\n输入: nums = [1,3,5,6], target = 0\n输出: 0\n示例 5:\n\n输入: nums = [1], target = 0\n输出: 0\n \n\n提示:\n\n1 <= nums.length <= 104  \n-104 <= nums[i] <= 104  \nnums 为无重复元素的升序排列数组  \n-104 <= target <= 104  \n#### 代码  \n```\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left,mid,right;\n        left=0;\n        right=nums.length-1;\n        while(right>=left){\n            mid=left+(right-left)/2; \n            if(nums[mid]==target){\n                return mid;\n            }\n            if(nums[mid]<target){\n                left=mid+1;\n            }\n           \n            if(nums[mid]>target){\n            right=mid-1;\n            }\n        }\n        return left;\n    }\n}\n```   \n常规二分，别想太多就好，不要去抽离实现结果。","tags":["LeetCode","数组"],"categories":["LeetCode ","数组"]},{"title":"287.第一个版本错误","url":"/posts/2485716078/","content":"####  题目描述  \n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 n 个版本 **[1, 2, ..., n]**，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n \n**示例 1：**  \n输入：n = 5, bad = 4  \n输出：4  \n解释：  \n调用 isBadVersion(3) -> false   \n调用 isBadVersion(5) -> true   \n调用 isBadVersion(4) -> true  \n所以，4 是第一个错误的版本。  \n**示例 2：**    \n输入：n = 1, bad = 1  \n输出：1  \n**提示：**\n1 <= bad <= n <= 231 - 1  \n####  初始想法  \n```\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left,mid,right;\n        left=1;\n        right=n;\n        mid=left+(right-left)/2;\n        while(right>left){\n            if(isBadVersion(mid)){\n                if(!isBadVersion(mid+1)){\n                    return mid+1;\n                }\n                else\n                    left=mid+1;\n            }\n            else{\n            if(isBadVersion(mid-1)){\n                return mid;\n            }   \n                else \n                right=mid-1;\n        }\n    } \n    return mid;\n\t}\n}\n```\n使用的是二分查找的方法，开始的想法是用传统的二分进行解决，但是提示超时，后面又改进一次，当mid本身为false且左侧为true时，则不需要再进行一次标识挪动，直接输出mid即可，反之同理，但是按照题目要求要尽量减少API的使用次数，但是如果按照我这种方法和之前调用API的次数不差多少，所以不出意外的出现了意外，又超时了。  \n####  改进  \n之前出现了一个错误，就是把mid的计算放到了`while()`之外，导致mid值不变，会调用数组长度的一半次数的API，导致超时，改进后将mid的计算放进循环内就好了。如下：  \n```\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left,mid,right;\n        left=1;\n        right=n;\n        while(right>left){\n        mid=left+(right-left)/2;\n           \n           if(isBadVersion(mid)){\n               right=mid;\n           }\n           else\n           left=mid+1;\n    } \n    return left;\n}\n}\n```\n这样就能通过了。。。。","tags":["LeetCode"],"categories":["LeetCode"]},{"title":"Git基本操作","url":"/posts/593176571/","content":"Git的工作就是创建和保存你项目的快找及修改后的的快照进行对比。  \n&emsp;&emsp;Git常用的命令有六个**git clone、git push、git add 、git commit、git checkout、git pull**\n  <!--more-->    \n&emsp;&emsp;各个命令之间的逻辑如下图\n  ![](https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg \"来源于runoob\")  \n  **说明**  \n  + workspace：工作空间  \n  + staging are ：暂存区/缓存区  \n  + local repository：版本库或本地仓库  \n  + remote repository：远程仓库  \n##### 一般的操作  \n```\ngit init  \ngit add .  \ngit conmmit  \n```\n+  git init - 初始化仓库。\n+ git add . - 添加文件到暂存区。\n+ git commit - 将暂存区内容添加到仓库中。  \n####  创建仓库命令（自建||下载） \n<table>  \n  <tr>\n    <th>命令</th>  \n    <th>说明</th>\n  </tr>\n    <tr>\n    <th>git init</th>  \n    <th>初始化仓库（自己创建目录并作为仓库使用）</th>\n  </tr>  \n  <tr>\n    <th>git clone</th>  \n    <th>拷贝一份远程仓库，下载一个现有的项目</th>\n  </tr>\n  </table>   \n  \n#### 提交与修改  \n下面是有关创建和提交项目的的快照命令。\n <table>  \n  <tr>\n    <th>命令</th>  \n    <th>说明</th>\n  </tr>\n    <tr>\n    <th>git add</th>  \n    <th>添加文件到仓库</th>\n  </tr>  \n  <tr>\n    <th>git status</th>  \n    <th>查看仓库当前的状态，显示有变更的文件</th>\n <tr>\n    <th>git diff</th>  \n    <th>比较文件的不同，也就是比较暂存区和工作区的差异</th>\n  </tr>  \n  <tr>\n    <th>git add</th>  \n    <th>添加文件到仓库</th>\n  </tr>  \n  <tr>\n    <th>git commit</th>  \n    <th>提交缓存区文件到本地仓库</th>\n  </tr>  \n  <tr>\n    <th>git reset</th>  \n    <th>回退版本</th>\n  </tr>  \n  <tr>\n    <th>git rm</th>  \n    <th>删除工作区文件（慎用）</th>\n  </tr>  \n  <tr>\n    <th>git mv</th>  \n    <th>移动或重命名工作区文件（与linux中的操作一直）</th>\n  </tr>  \n  </table>      \n  \n #### 提交日志  \n <table>  \n  <tr>\n    <th>命令</th>  \n    <th>说明</th>\n  </tr>\n    <tr>\n    <th>git log</th>  \n    <th>查看历史提交记录</th>\n  </tr>  \n  <tr>\n    <th>git blame &lt;file&gt;</th>  \n    <th>一列表的形式查看指定文件的历史修改记录</th>\n  </tr>\n  </table>   \n  \n  #### 远程操作   \n  <table>  \n  <tr>\n    <th>命令</th>  \n    <th>说明</th>\n  </tr>\n    <tr>\n    <th>git remote</th>  \n    <th>远程仓库操作</th>\n  </tr>  \n  <tr>\n    <th>git fetch</th>  \n    <th>从远程获取代码库</th>\n  </tr>  \n    <tr>\n    <th>git pull</th>  \n    <th>从远程仓库拉取（下载）代码并合并</th>\n  </tr>  \n  <tr>\n    <th>git push</th>  \n    <th>上传远程代码并合并</th>\n  </tr>\n  </table>","tags":["GIt"],"categories":["Git"]},{"title":"BUPT开学第一天","url":"/posts/1395521217/","content":"&emsp;&emsp;北邮开学第一天，突然发现自己首先要解决的不是怎样与舍友相处，怎样规划好自己未来三年的人生，首先要解决的是自己的心态问题，宿舍里两个土著，一个是二战的，一个还是百度实习的大佬，从交流中可以看出差别之大，其余的都是双一流学校的学生。看看自己的水平，感觉自己真的不是个啊，不过也没办法，既来之则安之。可能成长就是去面对那些自己不敢面对的东西吧，这3年没有了任何东西的加持，干干自己能走多远吧，希望将自己最脆弱的一面暴露出来并击碎吧!!!peace out~  \n  <div style=\"width:60%;margin:auto\">{% asset_img 1.jpg %}</div>","tags":["感悟","人生"],"categories":["感悟","人生"]},{"title":"Go语言结构","url":"/posts/3078468758/","content":"####  Go Hello World 实例  \n\nGo 语言的基础组成有以下几个部分：  \n+ 包声明 \n+ 引入包  \n+ 函数  \n+ 变量  \n+ 语句 & 表达式  \n+ 注释  \n<!--more-->\n接下来让我们来看下简单的代码，该代码输出了\"Hello World!\":  \n```\npackage main\nimport \"fmt\"\nfunc main() {\n   /* 这是我的第一个简单的程序 */\n   fmt.Println(\"Hello, World!\")\n}\n```\n1. 第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。\n\n2. 下一行 import \"fmt\" 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。\n\n3. 下一行 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。\n\n4. 下一行 /*...*/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。\n\n5. 下一行 fmt.Println(...) 可以将字符串输出到控制台，并在最后自动增加换行字符 \\n。 使用 fmt.Print(\"hello, world\\n\") 可以得到相同的结果。 Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。\n\n6. 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。  \n####  执行 Go 程序\n让我们来看下如何编写 Go 代码并执行它。步骤如下：  \n1. 打开编辑器如Sublime2，将以上代码添加到编辑器中。\n2. 将以上代码保存为 hello.go\n3. 打开命令行，并进入程序文件保存的目录中。\n4. 输入命令 go run hello.go 并按回车执行代码。\n5. 如果操作正确你将在屏幕上看到 \"Hello World!\" 字样的输出。  \n```\n$ go run hello.go\nHello, World!\n```\n####  注意  \n需要注意的是` { `不能单独放在一行，所以以下代码在运行时会产生错误：   \n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main()  \n{  // 错误，{ 不能在单独的行上\n    fmt.Println(\"Hello, World!\")\n}\n```\n#### PS  \n关于包，根据本地测试得出以下几点： \n+ 文件名与包名没有直接关系，不一定要将文件名与包名定成同一个。  \n+ 文件夹名与包名没有直接关系，并非需要一致。  \n+ 同一个文件夹下的文件只能有一个包名，否则编译报错。  \n文件结构:  \n\n```\nTest\n--helloworld.go\n\nmyMath\n--myMath1.go\n--myMath2.go\n```\n测试代码:  \n```\n// helloworld.go\npackage main\n\nimport (\n\"fmt\"\n\"./myMath\"\n)\n\nfunc main(){\n    fmt.Println(\"Hello World!\")\n    fmt.Println(mathClass.Add(1,1))\n    fmt.Println(mathClass.Sub(1,1))\n}\n```\n```\n// myMath1.go\npackage mathClass\nfunc Add(x,y int) int {\n    return x + y\n}\n```\n```\n// myMath2.go\npackage mathClass\nfunc Sub(x,y int) int {\n    return x - y\n}\n```","tags":["Go"],"categories":["Go"]},{"title":"Go初识","url":"/posts/956589985/"},{"url":"/posts/1/","content":"####  主动信息收集的原理   \n#####  主动信息收集的特点   \n+  直接与目标系统交互通信  \n+  无法避免留下访问的痕迹  \n+  使用受控的第三方电脑进行探测，使用代理或已经被控制的及其，做好被封杀的准备  \n+  扫描发送不同的探，根据返回结果判断目标状态  \n#####  发现目标主机的过程  \n+  识别存货主机，发现潜在被攻击目标  \n+  输出一个IP地址列表比如IP地址段IP地址范围\n+  使用二三四层进行探测发现  \n#####  OSI七层模型和TCP/IP五层模型  \n+  应用层   常见协议:HTTP,HTTPS,FTP,SMTP,POP3       \n+  表示层  处理两个同心系统中交换信息的表示方式 \n+  会话层   两个节点建立端链接\n+  传输层  建立主机端口到端口的链接  。四层交换机，四层路由器，协议：TCP，UDP\n+  网络成  通过IP寻址来建立两个节点之间的连接  。路由器，三层交换机。协议：IP，ICMP,RIP,IGMP\n+  数据链路层  使用MAC地址访问，进行差错检测  。网桥，网卡。协议 ：ARP,CSMA/CD\n+  物理层  物理媒介，各种电气属性   。中继器，集线器，双绞线\n#####   基于OSI模型进行扫描的优缺点   \n+ 1.二层扫描的优缺点  \n优点：扫描速度快、可靠  \n缺点：不可路由  \n+  2.三层扫描的优缺点  \n优点：可路由，速度较快   \n缺点：速度比二层慢，经常被边界防火墙过滤  \n+  3.四层扫描优缺点   \n优点：可路由且结果可靠，不太可能被防火墙过滤，可以发现所有端口都被过滤的主机   \n缺点： 基于状态过滤的防火墙可能过滤扫描 ，全端口扫描速度慢  \n####  基于ping命令的探测(IGMP)   \nping \nping 192.168.1.1 -c 5  控制发送包的数量   \ntraceroute baidu.com 查看经过的网络设备  对路由进行跟踪   \n####  ping的延伸  \n#####  ARPING  \n+ ARP协议：计算机通过ARP将IP地址转换成MAC地址。\n+ ARP工作原理：\n+ 使用arping命令查看局域网中的IP是否冲突（防止冒充网关）得学习写脚本啊，不会脚本寸步难行  \n#####  使用Netdiscover进行被动方式探测局域中存活的机器  \nNetdiscover是一个主动/被动的ARP侦查工具，可以在网络上扫描IP地址，检查在线主机或搜索为他们发送到的ARP请求。  \n+主动模式：  \n容易被发现，容易被封杀。eg:netdiscover -i eth0 -r 192.168.38.0/24  此命令就是使用主动方式进行探测，-i代表选择发送的网卡，-r表示选定探测的网段范围。   \n+被动模式：  \n不发送任何数据，采用嗅探的方法进行探测。eg：netdiscover -p   -p参数表示passive模式，不发送任何数据包  \n#####  使用hping3进行探测  \n使用hping3 -h 进行帮助查看。  \n+是一个明航下使用TCP/IP数据包组装/分析工具，通常web服务器会用来做压力测试使用，也可以进行DOS攻击的实验。同样，Hping每次只能扫描你个目标。  \n+  使用HPING进行压力测试  \n测试网站:http://www.xueshenit.com/   \n使用命令： hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source xueshenit.com   \n-c: 指定发送的包的数量 -d: 指定包的大小（字节）-S: 发送SYN包  -w:指定TCP窗口大小  -p：扫描端口 --flood: 洪水式攻击  --rand-source：随机IP，伪造IP地址（局域网内伪造，出网还是固定IP）   \n#####  使用FPING查看局域网中运行的机器  \n+ping的嘉庆版，可以ping一定范围的IP段  eg： fping -g 192.168.1.0/24 -c 1  >fping.txt"},{"title":"Next-neat 插件优化提升访问效率","url":"/posts/1376317895/","content":"&emsp;&emsp;对于任何一个网站来说，优化页面的访问速度是必须的，从体验来讲，没人能忍耐加载页面十秒以上或长时间处于空白或加载状态。优化访问速度的方法有很多，今天只介绍傻瓜式的插件安装方法：  \n#### 安装插件  \n&emsp;&emsp;在站点目录下Git bash一下，使用如下命令安装hexo-neat插件：  \n```\nnpm install hexo-neat --save\n```\n####  主配置_config.yml文末添加：（其中exclude板块是特别添加，针对你的静态资源进行筛选）  \n```\n# hexo-neat\n# md博文压缩\nneat_enable: true\n# 压缩html（ejs，swig等也属于html格式片段）\nneat_html:\n  enable: true\n  exclude:\n# 压缩css  \nneat_css:\n  enable: true\n  exclude:\n    - '*.min.css'\n    - '**/*.min.css'\n    - 'jquery.fancybox.min.css'\n    - '**/live2d-widget/waifu.css'\n# 压缩js\nneat_js:\n  enable: true\n  mangle: true #打印日志\n  output:\n  compress:\n  exclude: #排除文件\n    - '*.min.js'\n    - '**/*.min.js'\n    - 'jquery.fancybox.min.js'\n    - '**/live2d-widget/*.js'\n    - '**/live2d-widget/*.min.js'\n\n```\n####  运行（因为mangle: true #打印日志,我们能看到运行流程） \n#####  【INFO neat the html:xxxx.md】先压缩md文件的换行和空白   \n#####  【INFO neat the html: xxxx.ejs】压缩ejs配置文件（这里也有很多换行和空格），这是html片段格式文件。  \n#####  现在是neat工作最重要的部分之一：压缩js和css。  \n#####  最后是（hexo generate）将md文章转换成html语言格式的过程。\n<div style=\"width:50%;margin:auto\">{% asset_img 1.png %}</div>  \n<div style=\"width:50%;margin:auto\">{% asset_img 3.png %}</div>    \n\n####  每日一图  \n<div style=\"width:50%;margin:auto\">{% asset_img 2.jpg %}</div>","tags":["Hexo"],"categories":["Hexo"]},{"title":"Next 7.0 添加文章置顶","url":"/posts/1089908893/","content":"&emsp;&emsp;为了更好的表达人生情感，每个人的博客都会有个指定，Next 7.0的博客置顶操作如下：  \n\n####  安装插件  \n&emsp;&emsp;在根目录Blog打开Git Bash，执行下面的命令：  \n```\nnpm uninstall hexo-generator-index --save  \nnpm install hexo-generator-index-pin-top --save\n```\n\n####  设置指定标志     \n\n&emsp;&emsp;打开`blog/themes/hexo-theme-next/layout/_macro`目录下的post.swig文件，定位到`<div class=\"post-meta\">`标签下，插入如下代码：   \n\n```     \n{% if post.top %}\n\t<script type=\"text/html\" style='display:block'>\n    <i class=\"fa fa-thumb-tack\"></i>\n    <font color=\"RED\">置顶</font>\n    <span class=\"post-meta-divider\">|</span>\n    </script>\n{% endif %}  \n```\n\n#### 在文章中添加top   \n\n&emsp;&emsp;然后在需要置顶的文章的Front-matter中加上`top: true`即可，如下：   \n\n```\ntitle: 时也，运也，命也\nabbrlink: 931683055\ntags:\n  - 感悟\ncategories:\n  - 感悟\nauthor: 吕蒙正\ntop: true\ndate: 2021-08-24 12:18:00\n---  \n```\n\n####  效果  \n<div style=\"width:50%;margin:auto\">{% asset_img 1.png%}</div>  \n\n\n####  每日一图  \n\n<div style=\"width:50%;margin:auto\">{% asset_img 2.jpg %}</div>","tags":["Hexo"],"categories":["Hexo"]},{"title":"时也，运也，命也","url":"/posts/931683055/","content":"&emsp;&emsp;天有不测风云，人有旦夕祸福。蜈蚣百足，行不及蛇；雄鸡两翼，飞不过鸦。马有千里之程，无骑不能自往；人有冲天之志，非运不能自通。  \n&emsp;&emsp;盖闻：人生在世，富贵不能淫，贫贱不能移。文章盖世，孔子厄于陈邦；武略超群，太公钓于渭水。颜渊命短，殊非凶恶之徒；盗跖年长，岂是善良之辈。尧帝明圣，却生不肖之儿；瞽叟愚顽，反生大孝之子。张良原是布衣，萧何曾为县吏。晏子身无五尺，封作齐国宰相；孔明卧居草庐，能作蜀汉军师。楚霸虽雄，败于乌江自刎；汉王虽弱，竟有万里江山。李广有射虎之威，到老无封；冯唐有乘龙之才，一生不遇。韩信未遇之时，无一日三餐，及至遇行，腰悬三齐玉印，一旦时衰，死于阴人之手。  \n&emsp;&emsp;有先贫而后富，有老壮而少衰。满腹文章，白发竟然不中；才疏学浅，少年及第登科。深院宫娥，运退反为妓妾；风流妓女，时来配作夫人。  \n&emsp;&emsp;青春美女，却招愚蠢之夫；俊秀郎君，反配粗丑之妇。蛟龙未遇，潜水于鱼鳖之间；君子失时，拱手于小人之下。衣服虽破，常存仪礼之容；面带忧愁，每抱怀安之量。时遭不遇，只宜安贫守份；心若不欺，必然扬眉吐气。初贫君子，天然骨骼生成；乍富小人，不脱贫寒肌体。  \n&emsp;&emsp;天不得时，日月无光；地不得时，草木不生；水不得时，风浪不平；人不得时，利运不通。注福注禄，命里已安排定，富贵谁不欲？人若不依根基八字，岂能为卿为相？  \n&emsp;&emsp;余者，居洛阳之时，朝投僧寺，夜宿破窑。布衣不能遮其体，饘粥不能充其饥。上人嫌，下人憎，皆言余之贱也，余曰：非贱也，乃时也，运也，命也。余后登高及第，入中书，官至极品，位列三公，思衣则有绮罗千箱，思食则有百味珍馐，有挞百僚之杖，有斩佞臣之剑，出则壮士执鞭，入则佳人扶袂，廪有余粟，库有余财，人皆言余之贵也，余曰：非贵也，乃时也，运也，命也。   \n&emsp;&emsp;嗟呼！人生在世，富贵不可尽用，贫贱不可自欺，听由天地循环，周而复始焉。  \n          ","tags":["感悟"],"categories":["感悟"]},{"title":"DVWA配置下PHPStudy里MySQL无法正常开启","url":"/posts/2706012783/","content":"在配置PHPStudy中部分人会出现MySQL无法开启的情况，一般来说是与本地的MySQL服务冲突了，所以解决方案就是关掉本地的MySQL服务。  \n<!--more-->\n\n流程\n--\n\n此电脑->管理->服务，之后会出现以下界面\n\n![](https://img-blog.csdnimg.cn/20201109155242164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)\n\n选择其中的MySQL80（有的人可能是MySQLa或者其他，大家记得看一下），然后右键属性->停止\n\n![](https://img-blog.csdnimg.cn/20201109155736933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)\n\n在这里建议大家设置为手动开启，避免每次重启后还要进行调整，右键属性->启动类型->手动\n\n![](https://img-blog.csdnimg.cn/20201109155713854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)\n\n设置完之后重启一下PHPStudy试一下MySQL是否可以正常打开","tags":["安全","工具"],"categories":["安全"]},{"title":"kali下破解BurpSuite-血与泪的痛苦","url":"/posts/857850665/","content":"工欲善其事必先利其器，言简意赅，一共就两步：第一步，修改kali下高版本JDK（多环境共存）；第二步，安装破解版注册机。\n------------------------------------------------------------\n\n因为github上破解类的文章会被河蟹，所以就放在这里吧。  \n <!--more-->\n\n一、修改kali下高版本JDK\n---------------\n\n###     （1）准备工作        \n\n        1）kali系统\n\n        2）JDK：这里推荐1.8版本的JDK，如果你懒得这，可以[点这里](https://pan.baidu.com/s/1J0iYcZnXwdK6XR-MaCG9-g)下载（失效的话直接评论区要就行），提取码：ejos。\n\n###    （2）安装并调整JDK\n\n        1)首先创建文件夹package（可以自定义创建位置和名称）\n\n![](https://img-blog.csdnimg.cn/20210709114756560.png)\n\n    mkdir package\n\n        2)将之前下载好的1.8版本的JDK压缩包放到package文件夹中，然后进行解压缩\n\n    tar -zxvf jdk-8u161-linux-x64.tar.gz \n    \n\n        ![](https://img-blog.csdnimg.cn/20210709115705908.png)![](https://img-blog.csdnimg.cn/20210709115715789.png)\n\n         到这一步一般没啥问题\n\n3)配置环境变量\n\n        输入下面命令配置环境变量（一般不需要改动）       \n\n    export JAVA_HOME=/package/jdk1.7.0_80\n    export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n    export PATH=$PATH:$JAVA_HOME/bin\n\n        这三条命令可以直接在你当前环境下执行（注意分条执行），没有内容回显。\n\n4）给JDK1.8设置序列号（以我个人为例）\n\n        输入下面命令来设置序列号（如果你不是管理员用户，在命令之前加上sudo获取root权限）\n\n    update-alternatives  --install  /usr/bin/java  java  /root/package/jdk1.8.0_161/bin/java 1071\n    \n\n![](https://img-blog.csdnimg.cn/20210709130121889.png)\n\n         注意一下，最后的路径一定要指向一个可执行的名字叫java的脚本，比如上面的：/root/package/jdk1.8.0_161/bin/java\n\n        给某版本软件设置序列号时，install选项的参数是这样的：\n\n    --install link name path priority\n\n拓展一下有关uplate-alternatives：\n\n        增加：$sudo update-alternatives --install 程序生成的快捷方式的目标完整位置 **程序名** 程序其中一个版本的完整路径\n\n        配置：$sudo update-alternatives --config 程序名（如java）\n\n        删除：$sudo update-alternatives  --remove 程序名 其中不要版本的完整路径\n\n例子如下：\n\n    $sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-openjdk-i386/bin/java 1071\n    \n    $sudo update-alternatives --config java\n    \n    $sudo update-alternatives --remove java /usr/lib/jvm/java-7-openjdk-i386/jre/bin/java\n    \n    \n\n5）设置需要的JDK版本\n\n        输入以下命令：\n\n    update-alternatives  --config  java\n\n![](https://img-blog.csdnimg.cn/20210709131002857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)\n\n         选择想要设置的JDK版本对应的编号，回车就好。\n\n6）查看JDK版本\n\n![](https://img-blog.csdnimg.cn/20210709131221514.png)![](https://img-blog.csdnimg.cn/20210709131226782.png)\n\n 至此，JDK设置完成。\n\n二、Burpsuite注册机设置\n----------------\n\n 这里用的是大佬资源，先膜拜一下。\n\n### （1）准备工作\n\n下载注册机，需要的，直接[点这里](https://pan.baidu.com/s/1thBdEmjAFBGwXIJK_kB7mg)，失效评论区说声哈~\n\n        1）创建一个burpsuit文件夹（位置和名字可以自定义，一般默认家目录就行），把压缩包放进文件夹中，并进行解压缩。和上面一样不再赘述。\n\n注意：\n\n     （a）文件下载之后检查MD5值，防止被篡改，验证方法：使用命令 md5sum 文件名\n\n     hash值：\n    \n        Burp_Suite_Pro_v1.7.32_Loader_Keygen\\Burp_Suite_Pro_v1.7.32_Loader_Keygen\\burp-loader-keygen.jar\n        Size: 65220 bytes\n        Modified: 2018年1月25日, 17:01:33\n        MD5: A4A02E374695234412E2C66B0649B757\n        SHA1: 63EF57AA0FD7FDB6F6D2171CF946177C9C23B195\n        CRC32: 4F363E7B\n    \n        Burp_Suite_Pro_v1.7.32_Loader_Keygen\\Burp_Suite_Pro_v1.7.32_Loader_Keygen\\burpsuite_pro_v1.7.32.jar\n        Size: 27955758 bytes\n        Modified: 2018年2月3日, 10:02:08\n        MD5: D4D43E44769B121CFD930A13A2B06B4C\n        SHA1: C6CD0BBE402B75F4806D76A04D251474308415B8\n        CRC32: 0FD2072A\n    \n\n        (b)解压密码（密码也就是大佬的博客首页地址，没事可以去看看）：[mrxn.net](https://mrxn.net/)\n\n![](https://img-blog.csdnimg.cn/20210709132131358.png)\n\n（蓝色的是解压之后的，红色的是压缩包）\n\n        2）打开解压后的文件夹，一路点进去，知道找到如下图的位置（也就是最后了）\n\n![](https://img-blog.csdnimg.cn/2021070913264244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)\n\n        3）注册机破解\n\n使用以下命令运行jar包：\n\n    java -jar burp-loader-keygen.jar\n\n![](https://img-blog.csdnimg.cn/20210709133710466.png)\n\n 运行后会打开注册机如下图：\n\n![](https://img-blog.csdnimg.cn/20210709133835669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)\n\n 这里License Text 的内容随便填写，然后又点击run，会弹出一个窗口，提示你输入Enter license key，这时将上图中的License中的内容复制下来填进去\n\n![](https://img-blog.csdnimg.cn/20210709134228718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)\n\n 输入之后进行下一步，再弹出一个之后，点击manual activation（手动激活）（借鉴大佬的图）：\n\n![](https://img-blog.csdnimg.cn/20210709134607910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)\n\n接下来将request 粘贴到activation request ，将自动生成response，再粘贴到burp里最下面的response中，点击next下一步即可：\n\n![](https://img-blog.csdnimg.cn/20210709134729841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)\n\n激活成功：\n\n![](https://img-blog.csdnimg.cn/20210709134803240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)![](https://img-blog.csdnimg.cn/20210709134809840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1MjA3,size_16,color_FFFFFF,t_70)\n\n至此，所有步骤结束，直接运行kali上的Burpsuite就可以了，大家可以正常使用了 ，有问题还请多多指教了~~\n---------------------------------------------------------\n\n附上参考博客，大家感兴趣可以看一下：\n\n[https://mrxn.net/hacktools/Burp\\_Suite\\_Pro\\_v1\\_7\\_3\\_2\\_Loader\\_Keygen\\_Cracked\\_Share.html/comment-page-2#comments](https://mrxn.net/hacktools/Burp_Suite_Pro_v1_7_3_2_Loader_Keygen_Cracked_Share.html/comment-page-2#comments)\n\n[https://mrxn.net/hacktools/Burp\\_Suite\\_Pro\\_v1\\_7\\_3\\_2\\_Loader\\_Keygen\\_Cracked\\_Share.html/comment-page-2#comments](https://mrxn.net/hacktools/Burp_Suite_Pro_v1_7_3_2_Loader_Keygen_Cracked_Share.html/comment-page-2#comments)\n\n [https://www.cnblogs.com/sjjg/p/6033161.html](https://www.cnblogs.com/sjjg/p/6033161.html)  \n \n #### 每日一图  \n <div style=\"width:60%;margin:auto\">{% asset_img 1.jpg %}</div>","tags":["安全"],"categories":["安全"]},{"title":"Next 7.0 修改代码复制功能","url":"/posts/3140811385/","content":"&emsp;&emsp;之前在网上一直找怎样修改代码背景和添加复制功能，结果全部都是Next 5.0版本的，配置起来比较麻烦，而且一直不成功，不过架不住人家配出来的好看，最后发现Next 6.3版本及以上版本已经内置了代码复制功能，直接修改就可。  \n<!--more-->  \n#### 配置  \n\n&emsp;&emsp;修改主题下的配置文件`_config.yml`：  \n<div style=\"width:50%;margin:auto\">{% asset_img 1.png %}</div>  \n\n####  效果展示  \n```\ncodeblock:\n  # Code Highlight theme\n  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic\n  # See: https://github.com/chriskempson/tomorrow-theme\n  highlight_theme: night\n  # Add copy button on codeblock\n  copy_button:\n    enable: true\n    # Show text copy result.\n    show_result: true\n    # Available values: default | flat | mac\n    style: mac  \n```\n#### 每篇一图  \n<div style=\"width:60%;margin:auto\">{% asset_img 2.jpg %}</div>","tags":["Hexo"],"categories":["Hexo"]},{"title":"安装Hexo后台管理系统","url":"/posts/2214244853/","content":"&emsp;&emsp;由于使用Hexo搭建，不使用后台管理的时候，很难像WordPress和typecho那样直接写博文，而是要通过`hexo new '文章名'`来实现，很明显，这样编写博文十分耗时而且非常不方便，有了后台管理系统之后，可以使用一种可视化的方法编写md文件，设置标签和分类也是非常方便，下面开始介绍配置方式：  \n<!--more-->  \n###  安装Hexo-admin  \n&emsp;&emsp;可以直接查看其<a href=\"https://github.com/jaredly/hexo-admin\">Github项目</a>  \n\n&emsp;&emsp;进入`/hexo`目录(hexo根目录)，使用命令`npm install --save hexo-admin`安装hexo-admin。  \n  \n###  运行Hexo-admin  \n\n&emsp;&emsp;安装完毕后运行`hexo s`。出现下面运行结果：  \n<div style=\"width:50%;margin:auto\">{% asset_img 1.png %}</div>  \n&emsp;&emsp;根据运行结果，在浏览器地址栏中输入`http://localhost:4000/admin`进入后台管理界面,如下图所示：  \n<div style=\"width:50%;margin:auto\">{% asset_img 2.png %}</div>  \n\n###  配置安全认证  \n&emsp;&emsp;为了保证安全，在进入后台时要进行身份验证（总不能光着吧），增加一层账户密码的逻辑校验，流程如下：  \n#### 1.配置验证用的账户和密码  \n&emsp;&emsp;首先得到你的`password_hash`，首先点击`Setting`->`Setup authentification`,如下图所示：  \n<div style=\"width:50%;margin:auto\">{% asset_img 3.png %}</div>  \n<div style=\"width:50%;margin:auto\">{% asset_img 4.png %}</div>  \n&emsp;&emsp;进入之后设置你的相关信息，如下图所示：  \n<div style=\"width:50%;margin:auto\">{% asset_img 5.png %}</div> \n\n####  2.修改站点配置文件_config.yml  \n&emsp;&emsp;在完成上述步骤后，在最下面会生成一段代码，如下图所示：  \n<div style=\"width:50%;margin:auto\">{% asset_img 6.png %}</div>  \n复制上图的代码，打开站点配置文件`_config.yml`，在最后添加如下代码(注意缩进吧，骚年)，保存即可： \n\n```     \nadmin:\n  username: username\n  password_hash: $2a$10$L.XAIqIWgTc5S1zpvV3MEu7/rH34p4Is/nq824smv8EZ3lIPCp1su\n  secret: my super secret phrase  \n```  \n\n####  3.效果图   \n\n&emsp;&emsp;最后的效果如下所示（再登录需要账号密码认证了）：  \n<div style=\"width:50%;margin:auto\">{% asset_img 8.png %}</div>    \n\n### 每日一图  \n<div style=\"width:60%;margin:auto\">{% asset_img 7.jpg %}</div>","tags":["Hexo"],"categories":["Hexo"]},{"title":"Next 7.0 图片点击放大","url":"/posts/779553087/","content":"&emsp;&emsp;FancyBox 是基于 JQuery 开发的类 Lightbox 插件，可以将图片放大查看，同时支持对放大的图片添加阴影效果，并对于一组相关的图片添加导航操作按纽。对于 Next 7.0+ 主题来说，当文章出现图片时，无法将图片放大查看，为此其内置了 FancyBox3，关于该插件的具体介绍见其<a href=\"https://github.com/theme-next/theme-next-fancybox3\">Github项目</a>   \n<!--more-->  \n\n###  安装并导入\n&emsp;&emsp;由于安装基于JQuery框架，所以要想正常使用，首先安装并导入JQuery（同时可以解决Next 7.0中导入一些第三方插件时出现的`$`未定义错误）。解决方法为，打开`themes/hexo-theme-next/layout/_partials/head` 文件夹中的 `head.swig`文件，在其中添加如下代码(直接添加到最后空白处就得)：  \n'''JavaScript  \n\n<!-- 导入jquery -->\n<script src=\"https://ajax.aspnetcdn.com/ajax/jquery/jquery-3.5.1.min.js\"></script>\n'''\n###  修改主题配置文件_config.yml  \n&emsp;&emsp;找到主题配置文件中的`fancybox`字段，将`false`修改为`true`，如下图所示：  \n<div style=\"width:50%;margin:auto\">{% asset_img 1.png %}</div>  \n\n### 安装fancybox插件  \n&emsp;&emsp;进入到 `hexo-theme-next/next/`文件夹下，运行 Git Bash，执行以下代码:  \n'''JavaScript  \ngit clone https://github.com/theme-next/theme-next-fancybox3.git source/lib/fancy  \n\n'''\n###  效果图  \n&emsp;&emsp;安装后就可以发现你文章中的图片可以点击放大了，如下图，可点击放大  \n<div style=\"width:50%;margin:auto\">{% asset_img 2.jpg %}</div>","tags":["Hexo"],"categories":["Hexo"]},{"title":"Next 7.0+ 球型标签云","url":"/posts/2565730293/","content":"&emsp;&emsp;使用`tagcanvas.js`插件对样式进行修改实现球型标签云，修改步骤如下  \n\n###  下载插件  \n&emsp;&emsp;<a href=\"https://www.goat1000.com/tagcanvas.php#links\">点击这里</a>查看并下载插件，下载时右键下载链接，选择从链接另存文件为，保存`tagcanvas.js`文件，如下图所示：  \n<div style=\"width:50%;margin:auto\">{% asset_img 1.png %}</div>  \n&emsp;&emsp;将该插件下载后，放入 `hexo/themes/hexo-theme-next/source/js` 目录下。 \n<!--more-->\n\n###  新建标签云swig文件  \n\n&emsp;&emsp;在`/hexo/themes/hexo-theme-next/layout/_partials`目录下新建一个`tagcanvas.swig`的文件，并添加如下代码：  \n```JavaScript  \n<div class=\"tags\" id=\"myTags\">\n  <canvas width=\"500\" height=\"500\" id=\"my3DTags\">\n    <p>Anything in here will be replaced on browsers that support the canvas element</p>\n  </canvas>\n</div>\n<div class=\"tags\" id=\"tags\">\n  <ul style=\"display: none\">\n    {{ tagcloud({\n        min_font   : theme.tagcloud.min,\n        max_font   : theme.tagcloud.max,\n        amount     : theme.tagcloud.amount,\n        color      : true,\n        start_color: theme.tagcloud.start,\n        end_color  : theme.tagcloud.end})\n    }}\n  </ul>\n</div>\n<script type=\"text/javascript\" src=\"/js/tagcanvas.js\"></script>\n<script type=\"text/javascript\" >\n  window.onload = function() {\n    try {\n      TagCanvas.Start('my3DTags','tags',{\n        textFont: 'Georgia,Optima',\n        textColour: null,\n        outlineColour: 'black',\n        weight: true,\n        reverse: true,\n        depth: 0.8,\n        maxSpeed: 0.05,\n        bgRadius: 1,\n        freezeDecel: true\n      });\n    } catch(e) {\n      document.getElementById('myTags').style.display = 'none';\n    }\n  };\n</script>\n```\n\n\n###  修改page.swig  \n\n&emsp;&emsp;对 `themes/hexo-theme-next/layout/` 中的` page.swig` 文件进行修改,删除下图中标注位置的代码：  \n<div style=\"width:50%;margin:auto\">{% asset_img 2.png %}</div>  \n&emsp;&emsp;在被删除位置添加以下代码:  \n```  \n{# tagcanvas plugin 球型云标签 #}\n{% include '_partials/tagcanvas.swig' %}\n```\n\n###  修改_config.yml文件  \n\n&emsp;&emsp;打开主题下的配置文件，修改`tagcloud`字段，根据实际需求进行修改。  \n\n```  \n# 标签云设置页面\ntagcloud:\n    min: 12 # 最小字体尺寸，以px为单位\n    max: 30 # 最大字体尺寸，以px为单位\n    start: \"#ccc\" # 开始颜色 (hex, rgba, hsla or color keywords)\n    end: \"#111\" # 结束颜色 (hex, rgba, hsla or color keywords)\n    amount: 200 # 标签数量，当大于200个后，请进行更改  \n```\n\n###  效果图（目前标签较少，多了就好看了）    \n\n<div style=\"width:50%;margin:auto\">{% asset_img 3.png %}</div>  \n###  参考  \n&emsp;&emsp;参考段大佬的文章，<a href=\"https://alex-mcavoy.github.io/hexo/7be258c0.html\">点击这里访问大佬文章</a>","tags":["Hexo","Daily"],"categories":["Hexo"]},{"title":"智能合约与solidity","url":"/posts/3709194251/","content":"## 以太坊\n  &emsp;&emsp;以太坊（英语：Ethereum）是一个开源的有智能合约功能的公共区块链平台。通过其专用加密货币以太币（Ether，又称“以太坊”）提供去中心化的虚拟机（称为“以太虚拟机”Ethereum Virtual Machine）来处理点对点合约。 以太坊的概念首次在2013至2014年间由程序员维塔利克·布特林受比特币启发后提出，大意为“下一代加密货币与去中心化应用平台”，在2014年透过ICO众筹得以开始发展。 截至2018年6月，以太币是市值第二高的加密货币，以太坊亦被称为“第二代的区块链平台”，仅次于比特币。  \n<!--more-->\n## 智能合约\n  &emsp;&emsp;智能合约（英语：Smart contract）是一种特殊协议，在区块链内制定合约时使用，当中内含了代码函数 (Function)，亦能与其他合约进行交互、做决策、存储资料及发送以太币等功能。智能合约主力提供验证及运行合约内所订立的条件。智能合约允许在没有第三方的情况下进行可信交易。这些交易可追踪且不可逆转。智能合约概念于1994年由一名身兼计算机科学家及密码学专家的学者尼克·萨博首次提出。智能合同的目的是提供优于传统合同方法的安全，并减少与合同相关的其他交易成本。\n## solidity\n  &emsp;&emsp;Solidity是一种合约导向式语言，被应用于各种不同的区块链平台，其主要开发者为加文·伍德，Christian Reitwiessner，Alex Beregszaszi，Liana Husikyan，Yoichi Hirai和其他几位早期以太坊核心贡献者。Solidity 可使程序开发人员能在区块链上（例如以太坊）编写智能合约。\n### 历史\n  &emsp;&emsp;Solidity的语法概念最早是由加文·伍德在2014年提出，后期则以Christian Reitwiessner所领导的以太坊团队Solidity接手开发。该语言是针对以太坊虚拟机（EVM）所设计的四种语言之一（其他的还有Serpent，LLL，Viper（实验中）和Mutan（已弃用））。有关这些语言的更多信息，请参阅以太坊编程语言。 Solidity是目前在以太坊及其他以太坊竞争平台中的主要编程语言，例如Monax及其BurrowHyperledger的区块链就是使用Tendermint完成共识机制。 SWIFT亦已经使用Solidity在Burrow上完成了概念验证。 康奈尔大学的研究人员指出，Solidity即是导致DAO在2016年被黑客攻击的部分原因之一。他表示：“这实际上并不是DAO合同本身的缺陷或漏洞；技术上来说，DAO确实是在EVM上如预期般地被运行，反而是Solidity将安全上的漏洞引入了合约之中，而这些漏洞不仅没被开发社区察觉，Solidity语言的设计者们也忽略了。\n### 描述\n &emsp;&emsp;Solidity是一种静态类型的编程语言，用于开发在EVM上运行的智能合约。 Solidity被编译为可在EVM上运行的字节码。借由Solidity，开发人员能够编写出可自我运行其欲实现之商业逻辑的应用程序，该程序可被视为一份具权威性且永不可悔改的交易合约。对已具备程序编辑能力的人而言，编写Solidity的难易度就如同编写一般的编程语言。 Gavin Wood最初在规划Solidity语言时引用了ECMAScript的语法概念，使其对现有的Web开发者更容易入门；与ECMAScript不同的地方在于Solidity具有静态类型和0可变返回类型。而与目前其他EVM目标语言（如Serpent和Mutan）相比，其重要的差异在于Solidity具有一组复杂的成员变量使得合约可支持任意层次结构的映射和结构。Solidity也支持继承，包含C3线性化多重继承。 另外还引入了一个应用程序二进制接口（ABI），该接口（ABI）可在单一合同中实现多种类型安全的功能。     \n&emsp;&emsp;以下为使用Solidity编写的程序示例：  \n```solidity\npragma solidity ^0.4.0;\ncontract Helloworld{\n    string  myName= \"Helloworld\";\n    function getName()  public view returns(string){\n        return myName;\n    }\n    function changeName(string _newName) public{\n        myName= _newName;\n    } \n    function pureTest(string _name) pure public returns(string) {\n        return _name;\n    }\n}\n\n```  \n&emsp;&emsp;上述主要摘自维基百科，旨在初步了解智能合约的同学有一个初步的认识。","tags":["Solidity"],"categories":["Solidity"]},{"title":"你好呀~我的朋友","url":"/posts/3073087415/","content":"\n\n<h1 align=\"center\" style=\"font-weight:bold;\">hello world</h1>\n\n------\n\n​\t这是用来测试专栏和标签的内容\n\n<!--more-->\n\n后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。后面的文字是用来测试是否能够自动形成摘录。\n\n"}]